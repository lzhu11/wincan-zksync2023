{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport Web3 from \"web3\";\nimport web3CoreSubscriptions from \"web3-core-subscriptions\";\nimport ABIDecoder from \"web3-eth-abi\";\nimport { toHex } from \"web3-utils\";\nimport { formatBlock } from \"./util/hex\";\nimport { callWhenDone } from \"./util/promises\";\nimport { makeAlchemyContext } from \"./web3-adapter/alchemyContext\";\nimport { patchEnableCustomRPC } from \"./web3-adapter/customRPC\";\nimport { patchEthMaxPriorityFeePerGasMethod } from \"./web3-adapter/eth_maxPriorityFeePerGas\";\nimport { patchEthPrivateTransactionMethods } from \"./web3-adapter/eth_PrivateTransactions\";\nexport * from \"./alchemy-apis/types\";\nvar DEFAULT_MAX_RETRIES = 3;\nvar DEFAULT_RETRY_INTERVAL = 1000;\nvar DEFAULT_RETRY_JITTER = 250;\nvar DEFAULT_CONTRACT_ADDRESS = \"DEFAULT_TOKENS\";\nexport function createAlchemyWeb3(alchemyUrl, config) {\n  var fullConfig = fillInConfigDefaults(config);\n  var _a = makeAlchemyContext(alchemyUrl, fullConfig),\n    provider = _a.provider,\n    jsonRpcSenders = _a.jsonRpcSenders,\n    restSender = _a.restSender,\n    setWriteProvider = _a.setWriteProvider;\n  var alchemyWeb3 = new Web3(provider);\n  alchemyWeb3.setProvider = function () {\n    throw new Error(\"setProvider is not supported in Alchemy Web3. To change the provider used for writes, use setWriteProvider() instead.\");\n  };\n  alchemyWeb3.setWriteProvider = setWriteProvider;\n  function getNfts(params, callback) {\n    return callAlchemyRestEndpoint({\n      restSender: restSender,\n      callback: callback,\n      params: params,\n      path: \"getNFTs\"\n    });\n  }\n  alchemyWeb3.alchemy = {\n    getTokenAllowance: function getTokenAllowance(params, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        method: \"alchemy_getTokenAllowance\",\n        params: [params]\n      });\n    },\n    getTokenBalances: function getTokenBalances(address, contractAddresses, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        method: \"alchemy_getTokenBalances\",\n        params: [address, contractAddresses || DEFAULT_CONTRACT_ADDRESS],\n        processResponse: processTokenBalanceResponse\n      });\n    },\n    getTokenMetadata: function getTokenMetadata(address, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        params: [address],\n        method: \"alchemy_getTokenMetadata\"\n      });\n    },\n    getAssetTransfers: function getAssetTransfers(params, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        params: [__assign(__assign({}, params), {\n          fromBlock: params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,\n          toBlock: params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n          maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n        })],\n        method: \"alchemy_getAssetTransfers\"\n      });\n    },\n    getNftMetadata: function getNftMetadata(params, callback) {\n      return callAlchemyRestEndpoint({\n        restSender: restSender,\n        callback: callback,\n        params: params,\n        path: \"getNFTMetadata\"\n      });\n    },\n    getNfts: getNfts,\n    getTransactionReceipts: function getTransactionReceipts(params, callback) {\n      return callAlchemyJsonRpcMethod({\n        jsonRpcSenders: jsonRpcSenders,\n        callback: callback,\n        method: \"alchemy_getTransactionReceipts\",\n        params: [params]\n      });\n    }\n  };\n  patchSubscriptions(alchemyWeb3);\n  patchEnableCustomRPC(alchemyWeb3);\n  patchEthMaxPriorityFeePerGasMethod(alchemyWeb3);\n  patchEthPrivateTransactionMethods(alchemyWeb3);\n  return alchemyWeb3;\n}\nfunction fillInConfigDefaults(_a) {\n  var _b = _a === void 0 ? {} : _a,\n    _c = _b.writeProvider,\n    writeProvider = _c === void 0 ? getWindowProvider() : _c,\n    _d = _b.jsonRpcSenderMiddlewares,\n    jsonRpcSenderMiddlewares = _d === void 0 ? [] : _d,\n    _e = _b.maxRetries,\n    maxRetries = _e === void 0 ? DEFAULT_MAX_RETRIES : _e,\n    _f = _b.retryInterval,\n    retryInterval = _f === void 0 ? DEFAULT_RETRY_INTERVAL : _f,\n    _g = _b.retryJitter,\n    retryJitter = _g === void 0 ? DEFAULT_RETRY_JITTER : _g;\n  return {\n    writeProvider: writeProvider,\n    jsonRpcSenderMiddlewares: jsonRpcSenderMiddlewares,\n    maxRetries: maxRetries,\n    retryInterval: retryInterval,\n    retryJitter: retryJitter\n  };\n}\nfunction getWindowProvider() {\n  return typeof window !== \"undefined\" ? window.ethereum : null;\n}\nfunction callAlchemyJsonRpcMethod(_a) {\n  var _this = this;\n  var jsonRpcSenders = _a.jsonRpcSenders,\n    method = _a.method,\n    params = _a.params,\n    _b = _a.callback,\n    callback = _b === void 0 ? noop : _b,\n    _c = _a.processResponse,\n    processResponse = _c === void 0 ? identity : _c;\n  var promise = function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, jsonRpcSenders.send(method, params)];\n          case 1:\n            result = _a.sent();\n            return [2 /*return*/, processResponse(result)];\n        }\n      });\n    });\n  }();\n  callWhenDone(promise, callback);\n  return promise;\n}\nfunction callAlchemyRestEndpoint(_a) {\n  var _this = this;\n  var restSender = _a.restSender,\n    path = _a.path,\n    params = _a.params,\n    _b = _a.callback,\n    callback = _b === void 0 ? noop : _b,\n    _c = _a.processResponse,\n    processResponse = _c === void 0 ? identity : _c;\n  var fixedParams = fixArrayQueryParams(params);\n  var promise = function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, restSender.sendRestPayload(path, fixedParams)];\n          case 1:\n            result = _a.sent();\n            return [2 /*return*/, processResponse(result)];\n        }\n      });\n    });\n  }();\n  callWhenDone(promise, callback);\n  return promise;\n}\nfunction processTokenBalanceResponse(rawResponse) {\n  // Convert token balance fields from hex-string to decimal-string.\n  var fixedTokenBalances = rawResponse.tokenBalances.map(function (balance) {\n    return balance.tokenBalance != null ? __assign(__assign({}, balance), {\n      tokenBalance: ABIDecoder.decodeParameter(\"uint256\", balance.tokenBalance)\n    }) : balance;\n  });\n  return __assign(__assign({}, rawResponse), {\n    tokenBalances: fixedTokenBalances\n  });\n}\n/**\n * Updates Web3's internal subscription architecture to also handle Alchemy\n * specific subscriptions. This is to handle alternate namings of the existing\n * subscription endpoints, but the officially documented interfaces are\n * specified in the AlchemyEth interface.\n */\nfunction patchSubscriptions(web3) {\n  var eth = web3.eth;\n  var oldSubscribe = eth.subscribe.bind(eth);\n  eth.subscribe = function (type) {\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n    if (type === \"alchemy_fullPendingTransactions\" || type === \"alchemy_newFullPendingTransactions\") {\n      console.warn(\"This method is now deprecated. Please use `alchemy_pendingTransactions` instead.\");\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spreadArray([\"alchemy_newFullPendingTransactions\"], __read(rest)));\n      });\n    }\n    if (type === \"alchemy_filteredNewFullPendingTransactions\" || type === \"alchemy_filteredPendingTransactions\" || type === \"alchemy_filteredFullPendingTransactions\") {\n      console.warn(\"This method is now deprecated. Please use `alchemy_pendingTransactions` instead.\");\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spreadArray([\"alchemy_filteredNewFullPendingTransactions\"], __read(rest)));\n      });\n    }\n    if (type === \"alchemy_pendingTransactions\") {\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spreadArray([\"alchemy_pendingTransactions\"], __read(rest)));\n      });\n    }\n    return oldSubscribe.apply(void 0, __spreadArray([type], __read(rest)));\n  };\n}\n/**\n * VERY hacky wrapper to suppress a spurious warning when subscribing to an\n * Alchemy subscription that isn't built into Web3.\n */\nfunction suppressNoSubscriptionExistsWarning(f) {\n  var oldConsoleWarn = console.warn;\n  console.warn = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (typeof args[0] === \"string\" && args[0].includes(\" doesn't exist. Subscribing anyway.\")) {\n      return;\n    }\n    return oldConsoleWarn.apply(console, args);\n  };\n  try {\n    return f();\n  } finally {\n    console.warn = oldConsoleWarn;\n  }\n}\n/**\n * Another VERY hacky monkeypatch to make sure that we can take extra parameters to certain alchemy subscriptions\n * I hate doing this, but the other option is to fork web3-core and I think for now this is better\n */\nvar subscription = web3CoreSubscriptions.subscription;\nvar oldSubscriptionPrototypeValidateArgs = subscription.prototype._validateArgs;\nsubscription.prototype._validateArgs = function (args) {\n  if ([\"alchemy_filteredNewFullPendingTransactions\", \"alchemy_filteredPendingTransactions\", \"alchemy_filteredFullPendingTransactions\", \"alchemy_pendingTransactions\"].includes(this.subscriptionMethod)) {\n    // This particular subscription type is allowed to have additional parameters\n  } else {\n    if ([\"alchemy_fullPendingTransactions\", \"alchemy_newFullPendingTransactions\"].includes(this.subscriptionMethod)) {\n      if (this.options.subscription) {\n        this.options.subscription.subscriptionName = this.subscriptionMethod;\n      }\n    }\n    var validator = oldSubscriptionPrototypeValidateArgs.bind(this);\n    validator(args);\n  }\n};\nfunction noop() {\n  // Nothing.\n}\nfunction identity(x) {\n  return x;\n}\n/**\n * Alchemy's APIs receive multivalued params via keys with `[]` at the end.\n * Update any query params whose values are arrays to match this convention.\n */\nfunction fixArrayQueryParams(params) {\n  var result = {};\n  Object.keys(params).forEach(function (key) {\n    var value = params[key];\n    var fixedKey = Array.isArray(value) ? toArrayKey(key) : key;\n    result[fixedKey] = value;\n  });\n  return result;\n}\nfunction toArrayKey(key) {\n  return endsWith(key, \"[]\") ? key : key + \"[]\";\n}\n/**\n * Like `String#endsWith`, for older environments.\n */\nfunction endsWith(s, ending) {\n  var index = s.lastIndexOf(ending);\n  return index >= 0 && index === s.length - ending.length;\n}","map":null,"metadata":{},"sourceType":"module"}