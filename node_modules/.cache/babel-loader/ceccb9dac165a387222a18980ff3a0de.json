{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport assertNever from \"assert-never\";\nimport { delay, promisify } from \"../util/promises\";\nvar ALCHEMY_DISALLOWED_METHODS = [\"eth_accounts\", \"eth_sendTransaction\", \"eth_sign\", \"eth_signTypedData_v3\", \"eth_signTypedData\"];\nvar ALCHEMY_DISALLOWED_PREFIXES = [\"personal\"];\nexport function makeJsonRpcPayloadSender(alchemySendJsonRpc, config) {\n  // Copy middlewares from config.\n  var middlewares = [];\n  config.jsonRpcSenderMiddlewares.forEach(function (m) {\n    return middlewares.push(m);\n  });\n  var currentWriteProvider = config.writeProvider;\n  middlewares.push(function (payload) {\n    var disallowedMethod = getDisallowedMethod(payload);\n    if (!disallowedMethod) {\n      try {\n        return sendJsonRpcWithRetries(payload, alchemySendJsonRpc, config);\n      } catch (alchemyError) {\n        // Fallback to write provider, but if both fail throw the error from\n        // Alchemy.\n        if (!currentWriteProvider) {\n          throw alchemyError;\n        }\n        try {\n          return sendJsonRpcWithProvider(currentWriteProvider, payload);\n        } catch (_a) {\n          throw alchemyError;\n        }\n      }\n    } else {\n      if (!currentWriteProvider) {\n        throw new Error(\"No provider available for method \\\"\" + disallowedMethod + \"\\\"\");\n      }\n      return sendJsonRpcWithProvider(currentWriteProvider, payload);\n    }\n  });\n  var sendJsonRpcPayload = function sendJsonRpcPayload(payload) {\n    var getNext = function getNext(i) {\n      var middleware = middlewares[i];\n      return function () {\n        return middleware(payload, getNext(i + 1));\n      };\n    };\n    return getNext(0)();\n  };\n  function setWriteProvider(writeProvider) {\n    currentWriteProvider = writeProvider !== null && writeProvider !== void 0 ? writeProvider : null;\n  }\n  return {\n    sendJsonRpcPayload: sendJsonRpcPayload,\n    setWriteProvider: setWriteProvider\n  };\n}\nfunction sendJsonRpcWithProvider(provider, payload) {\n  var anyProvider = provider;\n  var sendMethod = (anyProvider.sendAsync ? anyProvider.sendAsync : anyProvider.send).bind(anyProvider);\n  return promisify(function (callback) {\n    return sendMethod(payload, callback);\n  });\n}\nfunction getDisallowedMethod(payload) {\n  var payloads = Array.isArray(payload) ? payload : [payload];\n  // Check if the payload method is a disallowed method or starts with a\n  // disallowed prefix.\n  var disallowedRequest = payloads.find(function (p) {\n    return ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0 || ALCHEMY_DISALLOWED_PREFIXES.some(function (prefix) {\n      return p.method.startsWith(prefix);\n    });\n  }) || undefined;\n  return disallowedRequest && disallowedRequest.method;\n}\nfunction sendJsonRpcWithRetries(payload, alchemySendJsonRpc, _a) {\n  var maxRetries = _a.maxRetries,\n    retryInterval = _a.retryInterval,\n    retryJitter = _a.retryJitter;\n  return __awaiter(this, void 0, void 0, function () {\n    var i, result, status_1, message, statusString;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          i = 0;\n          _b.label = 1;\n        case 1:\n          if (!(i < maxRetries + 1)) return [3 /*break*/, 5];\n          return [4 /*yield*/, alchemySendJsonRpc(payload)];\n        case 2:\n          result = _b.sent();\n          switch (result.type) {\n            case \"jsonrpc\":\n              return [2 /*return*/, result.response];\n            case \"rateLimit\":\n              break;\n            case \"networkError\":\n              {\n                status_1 = result.status, message = result.message;\n                statusString = status_1 !== 0 ? \"(\" + status_1 + \") \" : \"\";\n                throw new Error(statusString + \" \" + message);\n              }\n            default:\n              return [2 /*return*/, assertNever(result)];\n          }\n          return [4 /*yield*/, delay(retryInterval + (retryJitter * Math.random() | 0))];\n        case 3:\n          _b.sent();\n          _b.label = 4;\n        case 4:\n          i++;\n          return [3 /*break*/, 1];\n        case 5:\n          throw new Error(\"Rate limited for \" + (maxRetries + 1) + \" consecutive attempts.\");\n      }\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"module"}