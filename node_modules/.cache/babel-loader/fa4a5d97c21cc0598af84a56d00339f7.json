{"ast":null,"code":"import { __read, __spreadArray, __values } from \"tslib\";\nimport { isResponse } from \"../types\";\nexport function makeWebSocketSender(ws) {\n  var contextsById = new Map();\n  ws.addEventListener(\"message\", function (message) {\n    var response = JSON.parse(message.data);\n    if (!isResponse(response)) {\n      return;\n    }\n    var id = getIdFromResponse(response);\n    if (id === undefined) {\n      return;\n    }\n    var context = contextsById.get(id);\n    if (!context) {\n      return;\n    }\n    var resolve = context.resolve;\n    contextsById.delete(id);\n    if (!Array.isArray(response) && response.error && response.error.code === 429) {\n      resolve({\n        type: \"rateLimit\"\n      });\n    } else {\n      resolve({\n        response: response,\n        type: \"jsonrpc\"\n      });\n    }\n  });\n  ws.addEventListener(\"down\", function () {\n    __spreadArray([], __read(contextsById)).forEach(function (_a) {\n      var _b = __read(_a, 2),\n        id = _b[0],\n        _c = _b[1],\n        request = _c.request,\n        resolve = _c.resolve;\n      if (isWrite(request)) {\n        // Writes cannot be resent because they will fail for a duplicate nonce.\n        contextsById.delete(id);\n        resolve({\n          type: \"networkError\",\n          status: 0,\n          message: \"WebSocket closed before receiving a response for write request with id: \" + id + \".\"\n        });\n      }\n    });\n  });\n  ws.addEventListener(\"reopen\", function () {\n    var e_1, _a;\n    try {\n      for (var _b = __values(contextsById.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var request = _c.value.request;\n        ws.send(JSON.stringify(request));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n  return function (request) {\n    return new Promise(function (resolve) {\n      var id = getIdFromRequest(request);\n      if (id !== undefined) {\n        var existingContext = contextsById.get(id);\n        if (existingContext) {\n          var message = \"Another WebSocket request was made with the same id (\" + id + \") before a response was received.\";\n          console.error(message);\n          existingContext.resolve({\n            message: message,\n            type: \"networkError\",\n            status: 0\n          });\n        }\n        contextsById.set(id, {\n          request: request,\n          resolve: resolve\n        });\n      }\n      ws.send(JSON.stringify(request));\n    });\n  };\n}\nfunction getIdFromRequest(request) {\n  if (!Array.isArray(request)) {\n    return request.id;\n  }\n  return getCanonicalIdFromList(request.map(function (p) {\n    return p.id;\n  }));\n}\nfunction getIdFromResponse(response) {\n  if (!Array.isArray(response)) {\n    return response.id;\n  }\n  return getCanonicalIdFromList(response.map(function (p) {\n    return p.id;\n  }));\n}\n/**\n * Since the JSON-RPC spec allows responses to be returned in a different order\n * than sent, we need a mechanism for choosing a canonical id from a list that\n * doesn't depend on the order. This chooses the \"minimum\" id by an arbitrary\n * ordering: the smallest string if possible, otherwise the smallest number,\n * otherwise null.\n */\nfunction getCanonicalIdFromList(ids) {\n  var stringIds = ids.filter(function (id) {\n    return typeof id === \"string\";\n  });\n  if (stringIds.length > 0) {\n    return stringIds.reduce(function (bestId, id) {\n      return bestId < id ? bestId : id;\n    });\n  }\n  var numberIds = ids.filter(function (id) {\n    return typeof id === \"number\";\n  });\n  if (numberIds.length > 0) {\n    return Math.min.apply(Math, __spreadArray([], __read(numberIds)));\n  }\n  return ids.indexOf(null) >= 0 ? null : undefined;\n}\nfunction isWrite(request) {\n  return Array.isArray(request) ? request.every(isSingleWrite) : isSingleWrite(request);\n}\nvar WRITE_METHODS = [\"eth_sendTransaction\", \"eth_sendRawTransaction\"];\nfunction isSingleWrite(request) {\n  return WRITE_METHODS.includes(request.method);\n}","map":null,"metadata":{},"sourceType":"module"}