{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\n/**\n * Helper for converting functions which take a callback as their final argument\n * to functions which return a promise.\n */\nexport function promisify(f) {\n  return new Promise(function (resolve, reject) {\n    return f(function (error, result) {\n      if (error != null) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n}\n/**\n * Helper for converting functions which return a promise to functions which\n * take a callback as their final argument.\n */\nexport function callWhenDone(promise, callback) {\n  promise.then(function (result) {\n    callback(null, result);\n  }, function (error) {\n    callback(error);\n  });\n}\nexport function delay(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\nexport function withTimeout(promise, ms) {\n  return Promise.race([promise, new Promise(function (_, reject) {\n    return setTimeout(function () {\n      return reject(new Error(\"Timeout\"));\n    }, ms);\n  })]);\n}\nvar MIN_RETRY_DELAY = 1000;\nvar RETRY_BACKOFF_FACTOR = 2;\nvar MAX_RETRY_DELAY = 30000;\nexport function withBackoffRetries(f, retryCount, shouldRetry) {\n  if (shouldRetry === void 0) {\n    shouldRetry = function shouldRetry() {\n      return true;\n    };\n  }\n  return __awaiter(this, void 0, void 0, function () {\n    var nextWaitTime, i, error_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          nextWaitTime = 0;\n          i = 0;\n          _a.label = 1;\n        case 1:\n          if (!true) return [3 /*break*/, 7];\n          _a.label = 2;\n        case 2:\n          _a.trys.push([2, 4,, 6]);\n          return [4 /*yield*/, f()];\n        case 3:\n          return [2 /*return*/, _a.sent()];\n        case 4:\n          error_1 = _a.sent();\n          i++;\n          if (i >= retryCount || !shouldRetry(error_1)) {\n            throw error_1;\n          }\n          return [4 /*yield*/, delay(nextWaitTime)];\n        case 5:\n          _a.sent();\n          if (!shouldRetry(error_1)) {\n            throw error_1;\n          }\n          nextWaitTime = nextWaitTime === 0 ? MIN_RETRY_DELAY : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n          return [3 /*break*/, 6];\n        case 6:\n          return [3 /*break*/, 1];\n        case 7:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexport function makeCancelToken() {\n  var cancelled = false;\n  return {\n    cancel: function cancel() {\n      return cancelled = true;\n    },\n    isCancelled: function isCancelled() {\n      return cancelled;\n    }\n  };\n}\nexport function throwIfCancelled(isCancelled) {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\nexport var CANCELLED = new Error(\"Cancelled\");","map":null,"metadata":{},"sourceType":"module"}