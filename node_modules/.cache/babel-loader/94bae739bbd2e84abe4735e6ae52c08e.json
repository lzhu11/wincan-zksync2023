{"ast":null,"code":"import { __assign, __awaiter, __extends, __generator, __read, __spreadArray, __values } from \"tslib\";\nimport EventEmitter from \"eventemitter3\";\nimport { dedupeLogs, dedupeNewHeads, makeBackfiller } from \"../subscriptions/subscriptionBackfill\";\nimport { isSubscriptionEvent } from \"../types\";\nimport { fromHex } from \"../util/hex\";\nimport { makeResponse } from \"../util/jsonRpc\";\nimport { callWhenDone, makeCancelToken, throwIfCancelled, withBackoffRetries, withTimeout } from \"../util/promises\";\nvar HEARTBEAT_INTERVAL = 30000;\nvar HEARTBEAT_WAIT_TIME = 10000;\nvar BACKFILL_TIMEOUT = 60000;\nvar BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nvar RETAINED_EVENT_BLOCK_COUNT = 10;\nvar AlchemyWebSocketProvider = /** @class */function (_super) {\n  __extends(AlchemyWebSocketProvider, _super);\n  function AlchemyWebSocketProvider(ws, sendJsonRpcPayload, jsonRpcSenders) {\n    var _this = _super.call(this) || this;\n    _this.ws = ws;\n    _this.sendJsonRpcPayload = sendJsonRpcPayload;\n    _this.jsonRpcSenders = jsonRpcSenders;\n    // In the case of a WebSocket reconnection, all subscriptions are lost and we\n    // create new ones to replace them, but we want to create the illusion that\n    // the original subscriptions persist. Thus, maintain a mapping from the\n    // \"virtual\" subscription ids which are visible to the consumer to the\n    // \"physical\" subscription ids of the actual connections. This terminology is\n    // borrowed from virtual and physical memory, which has a similar mapping.\n    _this.virtualSubscriptionsById = new Map();\n    _this.virtualIdsByPhysicalId = new Map();\n    _this.cancelBackfill = noop;\n    _this.startHeartbeat = function () {\n      if (_this.heartbeatIntervalId != null) {\n        return;\n      }\n      _this.heartbeatIntervalId = setInterval(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var _a;\n          return __generator(this, function (_b) {\n            switch (_b.label) {\n              case 0:\n                _b.trys.push([0, 2,, 3]);\n                return [4 /*yield*/, withTimeout(this.jsonRpcSenders.send(\"net_version\"), HEARTBEAT_WAIT_TIME)];\n              case 1:\n                _b.sent();\n                return [3 /*break*/, 3];\n              case 2:\n                _a = _b.sent();\n                this.ws.reconnect();\n                return [3 /*break*/, 3];\n              case 3:\n                return [2 /*return*/];\n            }\n          });\n        });\n      }, HEARTBEAT_INTERVAL);\n    };\n    _this.stopHeartbeatAndBackfill = function () {\n      if (_this.heartbeatIntervalId != null) {\n        clearInterval(_this.heartbeatIntervalId);\n        _this.heartbeatIntervalId = undefined;\n      }\n      _this.cancelBackfill();\n    };\n    _this.handleMessage = function (event) {\n      var message = JSON.parse(event.data);\n      if (!isSubscriptionEvent(message)) {\n        return;\n      }\n      var physicalId = message.params.subscription;\n      var virtualId = _this.virtualIdsByPhysicalId.get(physicalId);\n      if (!virtualId) {\n        return;\n      }\n      var subscription = _this.virtualSubscriptionsById.get(virtualId);\n      if (subscription.method !== \"eth_subscribe\") {\n        _this.emitGenericEvent(virtualId, message.params.result);\n        return;\n      }\n      switch (subscription.params[0]) {\n        case \"newHeads\":\n          {\n            var newHeadsSubscription = subscription;\n            var newHeadsMessage = message;\n            var isBackfilling = newHeadsSubscription.isBackfilling,\n              backfillBuffer = newHeadsSubscription.backfillBuffer;\n            var result = newHeadsMessage.params.result;\n            if (isBackfilling) {\n              addToNewHeadsEventsBuffer(backfillBuffer, result);\n            } else {\n              _this.emitNewHeadsEvent(virtualId, result);\n            }\n            break;\n          }\n        case \"logs\":\n          {\n            var logsSubscription = subscription;\n            var logsMessage = message;\n            var isBackfilling = logsSubscription.isBackfilling,\n              backfillBuffer = logsSubscription.backfillBuffer;\n            var result = logsMessage.params.result;\n            if (isBackfilling) {\n              addToLogsEventsBuffer(backfillBuffer, result);\n            } else {\n              _this.emitLogsEvent(virtualId, result);\n            }\n            break;\n          }\n        default:\n          _this.emitGenericEvent(virtualId, message.params.result);\n      }\n    };\n    _this.handleReopen = function () {\n      var e_1, _a;\n      _this.virtualIdsByPhysicalId.clear();\n      var _b = makeCancelToken(),\n        cancel = _b.cancel,\n        isCancelled = _b.isCancelled;\n      _this.cancelBackfill = cancel;\n      var _loop_1 = function _loop_1(subscription) {\n        (function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var error_1;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  _a.trys.push([0, 2,, 3]);\n                  return [4 /*yield*/, this.resubscribeAndBackfill(isCancelled, subscription)];\n                case 1:\n                  _a.sent();\n                  return [3 /*break*/, 3];\n                case 2:\n                  error_1 = _a.sent();\n                  if (!isCancelled()) {\n                    console.error(\"Error while backfilling \\\"\" + subscription.params[0] + \"\\\" subscription. Some events may be missing.\", error_1);\n                  }\n                  return [3 /*break*/, 3];\n                case 3:\n                  return [2 /*return*/];\n              }\n            });\n          });\n        })();\n      };\n\n      try {\n        for (var _c = __values(_this.virtualSubscriptionsById.values()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var subscription = _d.value;\n          _loop_1(subscription);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      _this.startHeartbeat();\n    };\n    _this.backfiller = makeBackfiller(jsonRpcSenders);\n    _this.addSocketListeners();\n    _this.startHeartbeat();\n    return _this;\n  }\n  AlchemyWebSocketProvider.prototype.send = function (request, callback) {\n    if (isSubscribeRequest(request)) {\n      var id = request.id;\n      if (id === undefined) {\n        // The JSON-RPC spec says to return nothing if there is no request id.\n        return;\n      }\n      callWhenDone(this.subscribe(request), callback);\n      return;\n    }\n    if (isUnsubscribeRequest(request)) {\n      callWhenDone(this.unsubscribe(request), callback);\n      return;\n    }\n    callWhenDone(this.sendJsonRpcPayload(request), callback);\n  };\n  AlchemyWebSocketProvider.prototype.supportsSubscriptions = function () {\n    return true;\n  };\n  AlchemyWebSocketProvider.prototype.disconnect = function (code, reason) {\n    this.removeSocketListeners();\n    this.removeAllListeners();\n    this.stopHeartbeatAndBackfill();\n    this.ws.close(code, reason);\n  };\n  AlchemyWebSocketProvider.prototype.connect = function () {\n    // No-op. We're already connected when passed a websocket in the\n    // constructor.\n  };\n  AlchemyWebSocketProvider.prototype.reset = function () {\n    // No-op.\n  };\n  AlchemyWebSocketProvider.prototype.reconnect = function () {\n    // No-op. This isn't called anywhere.\n  };\n  AlchemyWebSocketProvider.prototype.subscribe = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var method, _a, params, startingBlockNumber, response, id;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            method = request.method, _a = request.params, params = _a === void 0 ? [] : _a;\n            return [4 /*yield*/, this.getBlockNumber()];\n          case 1:\n            startingBlockNumber = _b.sent();\n            return [4 /*yield*/, this.sendJsonRpcPayload(request)];\n          case 2:\n            response = _b.sent();\n            id = response.result;\n            this.virtualSubscriptionsById.set(id, {\n              method: method,\n              params: params,\n              startingBlockNumber: startingBlockNumber,\n              virtualId: id,\n              physicalId: id,\n              sentEvents: [],\n              isBackfilling: false,\n              backfillBuffer: []\n            });\n            this.virtualIdsByPhysicalId.set(id, id);\n            return [2 /*return*/, makeResponse(request.id, id)];\n        }\n      });\n    });\n  };\n  AlchemyWebSocketProvider.prototype.unsubscribe = function (request) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var subscriptionId, virtualSubscription, physicalId, physicalRequest;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            subscriptionId = (_a = request.params) === null || _a === void 0 ? void 0 : _a[0];\n            virtualSubscription = this.virtualSubscriptionsById.get(subscriptionId);\n            if (!virtualSubscription) {\n              return [2 /*return*/, makeResponse(request.id, false)];\n            }\n            physicalId = virtualSubscription.physicalId;\n            physicalRequest = __assign(__assign({}, request), {\n              params: [physicalId]\n            });\n            return [4 /*yield*/, this.sendJsonRpcPayload(physicalRequest)];\n          case 1:\n            _b.sent();\n            this.virtualSubscriptionsById.delete(subscriptionId);\n            this.virtualIdsByPhysicalId.delete(physicalId);\n            return [2 /*return*/, makeResponse(request.id, true)];\n        }\n      });\n    });\n  };\n  AlchemyWebSocketProvider.prototype.addSocketListeners = function () {\n    this.ws.addEventListener(\"message\", this.handleMessage);\n    this.ws.addEventListener(\"reopen\", this.handleReopen);\n    this.ws.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  };\n  AlchemyWebSocketProvider.prototype.removeSocketListeners = function () {\n    this.ws.removeEventListener(\"message\", this.handleMessage);\n    this.ws.removeEventListener(\"reopen\", this.handleReopen);\n    this.ws.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  };\n  AlchemyWebSocketProvider.prototype.resubscribeAndBackfill = function (isCancelled, subscription) {\n    return __awaiter(this, void 0, void 0, function () {\n      var virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber, physicalId, _a, backfillEvents, events, filter_1, backfillEvents, events;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            virtualId = subscription.virtualId, method = subscription.method, params = subscription.params, sentEvents = subscription.sentEvents, backfillBuffer = subscription.backfillBuffer, startingBlockNumber = subscription.startingBlockNumber;\n            subscription.isBackfilling = true;\n            backfillBuffer.length = 0;\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1,, 9, 10]);\n            return [4 /*yield*/, this.jsonRpcSenders.send(method, params)];\n          case 2:\n            physicalId = _b.sent();\n            throwIfCancelled(isCancelled);\n            subscription.physicalId = physicalId;\n            this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n            _a = params[0];\n            switch (_a) {\n              case \"newHeads\":\n                return [3 /*break*/, 3];\n              case \"logs\":\n                return [3 /*break*/, 5];\n            }\n            return [3 /*break*/, 7];\n          case 3:\n            return [4 /*yield*/, withBackoffRetries(function () {\n              return withTimeout(_this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT);\n            }, BACKFILL_RETRIES, function () {\n              return !isCancelled();\n            })];\n          case 4:\n            backfillEvents = _b.sent();\n            throwIfCancelled(isCancelled);\n            events = dedupeNewHeads(__spreadArray(__spreadArray([], __read(backfillEvents)), __read(backfillBuffer)));\n            events.forEach(function (event) {\n              return _this.emitNewHeadsEvent(virtualId, event);\n            });\n            return [3 /*break*/, 8];\n          case 5:\n            filter_1 = params[1] || {};\n            return [4 /*yield*/, withBackoffRetries(function () {\n              return withTimeout(_this.backfiller.getLogsBackfill(isCancelled, filter_1, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT);\n            }, BACKFILL_RETRIES, function () {\n              return !isCancelled();\n            })];\n          case 6:\n            backfillEvents = _b.sent();\n            throwIfCancelled(isCancelled);\n            events = dedupeLogs(__spreadArray(__spreadArray([], __read(backfillEvents)), __read(backfillBuffer)));\n            events.forEach(function (event) {\n              return _this.emitLogsEvent(virtualId, event);\n            });\n            return [3 /*break*/, 8];\n          case 7:\n            return [3 /*break*/, 8];\n          case 8:\n            return [3 /*break*/, 10];\n          case 9:\n            subscription.isBackfilling = false;\n            backfillBuffer.length = 0;\n            return [7 /*endfinally*/];\n          case 10:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  AlchemyWebSocketProvider.prototype.getBlockNumber = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockNumberHex;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.jsonRpcSenders.send(\"eth_blockNumber\")];\n          case 1:\n            blockNumberHex = _a.sent();\n            return [2 /*return*/, fromHex(blockNumberHex)];\n        }\n      });\n    });\n  };\n  AlchemyWebSocketProvider.prototype.emitNewHeadsEvent = function (virtualId, result) {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  };\n  AlchemyWebSocketProvider.prototype.emitLogsEvent = function (virtualId, result) {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  };\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   */\n  AlchemyWebSocketProvider.prototype.emitAndRememberEvent = function (virtualId, result, getBlockNumber) {\n    var subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(subscription.sentEvents, __assign({}, result), getBlockNumber);\n    this.emitGenericEvent(virtualId, result);\n  };\n  AlchemyWebSocketProvider.prototype.emitGenericEvent = function (virtualId, result) {\n    var event = {\n      jsonrpc: \"2.0\",\n      method: \"eth_subscription\",\n      params: {\n        subscription: virtualId,\n        result: result\n      }\n    };\n    this.emit(\"data\", event);\n  };\n  return AlchemyWebSocketProvider;\n}(EventEmitter);\nexport { AlchemyWebSocketProvider };\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\nfunction addToLogsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n/**\n * Adds a new event to an array of events, evicting any events which\n * are so old that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\n  var currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  var firstGoodIndex = pastEvents.findIndex(function (e) {\n    return getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT;\n  });\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\nfunction isSubscribeRequest(request) {\n  return !Array.isArray(request) && request.method === \"eth_subscribe\";\n}\nfunction isUnsubscribeRequest(request) {\n  return !Array.isArray(request) && request.method === \"eth_unsubscribe\";\n}\nfunction getNewHeadsBlockNumber(event) {\n  return fromHex(event.number);\n}\nfunction getLogsBlockNumber(event) {\n  return fromHex(event.blockNumber);\n}\nfunction noop() {\n  // Nothing.\n}","map":null,"metadata":{},"sourceType":"module"}