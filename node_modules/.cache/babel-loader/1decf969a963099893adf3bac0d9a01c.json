{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport { fromHex, toHex } from \"../util/hex\";\nimport { throwIfCancelled } from \"../util/promises\";\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed\n * for a week.\n */\nvar MAX_BACKFILL_BLOCKS = 120;\n/**\n * The maximum number of requests that can be included in a single batch request.\n * This value is enforced by the backend.\n */\nvar MAX_BATCH_SIZE = 10;\nexport function makeBackfiller(jsonRpcSenders) {\n  return {\n    getNewHeadsBackfill: getNewHeadsBackfill,\n    getLogsBackfill: getLogsBackfill\n  };\n  function getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var toBlockNumber, lastSeenBlockNumber, minBlockNumber, reorgHeads, intermediateHeads;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            throwIfCancelled(isCancelled);\n            return [4 /*yield*/, getBlockNumber()];\n          case 1:\n            toBlockNumber = _a.sent();\n            throwIfCancelled(isCancelled);\n            if (previousHeads.length === 0) {\n              return [2 /*return*/, getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1, toBlockNumber + 1)];\n            }\n            lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\n            minBlockNumber = Math.max(0, lastSeenBlockNumber - MAX_BACKFILL_BLOCKS);\n            if (lastSeenBlockNumber < minBlockNumber) {\n              return [2 /*return*/, getHeadEventsInRange(minBlockNumber, toBlockNumber + 1)];\n            }\n            return [4 /*yield*/, getReorgHeads(isCancelled, previousHeads)];\n          case 2:\n            reorgHeads = _a.sent();\n            throwIfCancelled(isCancelled);\n            return [4 /*yield*/, getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1)];\n          case 3:\n            intermediateHeads = _a.sent();\n            throwIfCancelled(isCancelled);\n            return [2 /*return*/, __spreadArray(__spreadArray([], __read(reorgHeads)), __read(intermediateHeads))];\n        }\n      });\n    });\n  }\n  function getReorgHeads(isCancelled, previousHeads) {\n    return __awaiter(this, void 0, void 0, function () {\n      var result, i, oldEvent, blockHead;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            result = [];\n            i = previousHeads.length - 1;\n            _a.label = 1;\n          case 1:\n            if (!(i >= 0)) return [3 /*break*/, 4];\n            oldEvent = previousHeads[i];\n            return [4 /*yield*/, getBlockByNumber(fromHex(oldEvent.number))];\n          case 2:\n            blockHead = _a.sent();\n            throwIfCancelled(isCancelled);\n            if (oldEvent.hash === blockHead.hash) {\n              return [3 /*break*/, 4];\n            }\n            result.push(toNewHeadsEvent(blockHead));\n            _a.label = 3;\n          case 3:\n            i--;\n            return [3 /*break*/, 1];\n          case 4:\n            return [2 /*return*/, result.reverse()];\n        }\n      });\n    });\n  }\n  function getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function () {\n      var batchParts, headEventBatches, i, batchedBlockHeads, blockHeads;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (fromBlockInclusive >= toBlockExclusive) {\n              return [2 /*return*/, []];\n            }\n            batchParts = [];\n            headEventBatches = [];\n            for (i = fromBlockInclusive; i < toBlockExclusive; i++) {\n              batchParts.push({\n                method: \"eth_getBlockByNumber\",\n                params: [toHex(i), false]\n              });\n              if (batchParts.length % MAX_BATCH_SIZE === 0) {\n                headEventBatches.push(jsonRpcSenders.sendBatch(batchParts));\n                batchParts = [];\n              }\n            }\n            if (batchParts.length > 0) {\n              headEventBatches.push(jsonRpcSenders.sendBatch(batchParts));\n            }\n            return [4 /*yield*/, Promise.all(headEventBatches)];\n          case 1:\n            batchedBlockHeads = _a.sent();\n            blockHeads = batchedBlockHeads.reduce(function (acc, batch) {\n              return acc.concat(batch);\n            }, []);\n            return [2 /*return*/, blockHeads.map(toNewHeadsEvent)];\n        }\n      });\n    });\n  }\n  function getBlockByNumber(blockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, jsonRpcSenders.send(\"eth_getBlockByNumber\", [toHex(blockNumber), false])];\n      });\n    });\n  }\n  function getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var toBlockNumber, lastSeenBlockNumber, minBlockNumber, commonAncestorNumber, removedLogs, addedLogs;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            throwIfCancelled(isCancelled);\n            return [4 /*yield*/, getBlockNumber()];\n          case 1:\n            toBlockNumber = _a.sent();\n            throwIfCancelled(isCancelled);\n            if (previousLogs.length === 0) {\n              return [2 /*return*/, getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1, toBlockNumber + 1)];\n            }\n            lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\n            minBlockNumber = Math.max(0, lastSeenBlockNumber - MAX_BACKFILL_BLOCKS);\n            if (lastSeenBlockNumber < minBlockNumber) {\n              return [2 /*return*/, getLogsInRange(filter, minBlockNumber, toBlockNumber + 1)];\n            }\n            return [4 /*yield*/, getCommonAncestorNumber(isCancelled, previousLogs)];\n          case 2:\n            commonAncestorNumber = _a.sent();\n            throwIfCancelled(isCancelled);\n            removedLogs = previousLogs.filter(function (log) {\n              return fromHex(log.blockNumber) > commonAncestorNumber;\n            }).map(function (log) {\n              return __assign(__assign({}, log), {\n                removed: true\n              });\n            });\n            return [4 /*yield*/, getLogsInRange(filter, commonAncestorNumber + 1, toBlockNumber + 1)];\n          case 3:\n            addedLogs = _a.sent();\n            throwIfCancelled(isCancelled);\n            return [2 /*return*/, __spreadArray(__spreadArray([], __read(removedLogs)), __read(addedLogs))];\n        }\n      });\n    });\n  }\n  function getCommonAncestorNumber(isCancelled, previousLogs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var i, _a, blockHash, blockNumber, hash;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            i = previousLogs.length - 1;\n            _b.label = 1;\n          case 1:\n            if (!(i >= 0)) return [3 /*break*/, 4];\n            _a = previousLogs[i], blockHash = _a.blockHash, blockNumber = _a.blockNumber;\n            return [4 /*yield*/, getBlockByNumber(fromHex(blockNumber))];\n          case 2:\n            hash = _b.sent().hash;\n            throwIfCancelled(isCancelled);\n            if (blockHash === hash) {\n              return [2 /*return*/, fromHex(blockNumber)];\n            }\n            _b.label = 3;\n          case 3:\n            i--;\n            return [3 /*break*/, 1];\n          case 4:\n            return [2 /*return*/, Number.NEGATIVE_INFINITY];\n        }\n      });\n    });\n  }\n  function getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function () {\n      var rangeFilter;\n      return __generator(this, function (_a) {\n        if (fromBlockInclusive >= toBlockExclusive) {\n          return [2 /*return*/, []];\n        }\n        rangeFilter = __assign(__assign({}, filter), {\n          fromBlock: toHex(fromBlockInclusive),\n          toBlock: toHex(toBlockExclusive - 1)\n        });\n        return [2 /*return*/, jsonRpcSenders.send(\"eth_getLogs\", [rangeFilter])];\n      });\n    });\n  }\n  function getBlockNumber() {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockNumberHex;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, jsonRpcSenders.send(\"eth_blockNumber\")];\n          case 1:\n            blockNumberHex = _a.sent();\n            return [2 /*return*/, fromHex(blockNumberHex)];\n        }\n      });\n    });\n  }\n}\nfunction toNewHeadsEvent(head) {\n  var result = __assign({}, head);\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\nexport function dedupeNewHeads(events) {\n  return dedupe(events, function (event) {\n    return event.hash;\n  });\n}\nexport function dedupeLogs(events) {\n  return dedupe(events, function (event) {\n    return event.blockHash + \"/\" + event.logIndex;\n  });\n}\nfunction dedupe(items, getKey) {\n  var keysSeen = new Set();\n  var result = [];\n  items.forEach(function (item) {\n    var key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}