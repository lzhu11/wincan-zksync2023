{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport fetchPonyfill from \"fetch-ponyfill\";\nimport URI from \"urijs\";\nimport { delay } from \"../util/promises\";\nexport function makeRestPayloadSender(_a) {\n  var _this = this;\n  var url = _a.url,\n    config = _a.config;\n  // The rest payload sender only works for alchemy.com http endpoints.\n  var error;\n  if (/^wss?:\\/\\//.test(url)) {\n    error = \"Alchemy rest endpoints are not available via websockets\";\n  }\n  if (!url.includes(\"alchemy\")) {\n    error = \"Alchemy specific rest endpoints are not available with a non Alchemy provider.\";\n  }\n  if (url.includes(\"alchemyapi.io\") && !url.includes(\"eth-\")) {\n    error = \"Alchemy specific rest endpoints on L2 networks are not available with our legacy endpoints on alchemyapi.io. Please switch over to alchemy.com\";\n  }\n  // Don't use the native `URL` class for this. It doesn't work in React Native.\n  var urlObject = new URI(url);\n  var origin = urlObject.origin();\n  var pathname = urlObject.path();\n  var apiKey = pathname.substring(pathname.lastIndexOf(\"/\") + 1);\n  var fetch = fetchPonyfill().fetch;\n  // NFT endpoints are prefixed differently, so the path must be constructed separately\n  var NFT_ENDPOINTS = [\"getNFTs\", \"getNFTMetadata\"];\n  var NFT_PREFIX = \"nft/v2/\";\n  var isNftPath = function isNftPath(path) {\n    return NFT_ENDPOINTS.includes(path);\n  };\n  var formatNftPath = function formatNftPath(path) {\n    return NFT_PREFIX + apiKey + \"/\" + path;\n  };\n  var sendRestPayload = function sendRestPayload(path, payload) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var maxRetries, retryInterval, retryJitter, endpoint, i, response, status_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (error) {\n              throw new Error(error);\n            }\n            maxRetries = config.maxRetries, retryInterval = config.retryInterval, retryJitter = config.retryJitter;\n            if (!(origin && apiKey)) return [3 /*break*/, 6];\n            endpoint = new URI(origin).search(payload).path(isNftPath(path) ? formatNftPath(path) : apiKey + path).toString();\n            i = 0;\n            _a.label = 1;\n          case 1:\n            if (!(i < maxRetries + 1)) return [3 /*break*/, 5];\n            return [4 /*yield*/, fetch(endpoint)];\n          case 2:\n            response = _a.sent();\n            status_1 = response.status;\n            switch (status_1) {\n              case 200:\n                return [2 /*return*/, response.json()];\n              case 429:\n                break;\n              default:\n                throw new Error(response.status + \":\" + response.statusText);\n            }\n            return [4 /*yield*/, delay(retryInterval + (retryJitter * Math.random() | 0))];\n          case 3:\n            _a.sent();\n            _a.label = 4;\n          case 4:\n            i++;\n            return [3 /*break*/, 1];\n          case 5:\n            throw new Error(\"Rate limited for \" + (maxRetries + 1) + \" consecutive attempts.\");\n          case 6:\n            return [2 /*return*/, Promise.resolve()];\n        }\n      });\n    });\n  };\n  return {\n    sendRestPayload: sendRestPayload\n  };\n}","map":null,"metadata":{},"sourceType":"module"}